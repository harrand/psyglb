glb_parse_state ::= struct
{
	result : glb;
	hdr : glb_header;
};

glb_header ::= struct
{
	magic : u32;
	version : u32;
	length : u32;
};

glb_chunk ::= struct
{
	length : u32;
	type : u32;
	data : u8?;
};

glb_validate_hdr ::= func(s : glb_parse_state mut? -> v0)
{
	hdr ::= s->hdr;
	if(hdr.magic != 0x46546C67)
	{
		glb_parse_error(s, "invalid glb header - magic mismatch");
	}
	if(hdr.version != 2)
	{
		glb_parse_error(s, "invalid glb header - must be version 2");
	}
};

glb_parse_error ::= func(s : glb_parse_state mut?, errmsg : u8? -> v0)
{
	s->result.errmsg = errmsg;
};

glb_parse_chunk ::= func(buf : u8? -> glb_chunk)
{
	ret ::= deref((buf)@glb_chunk mut?);
	// directly after length + type
	ret.data = (buf # (__sizeof(u32) + __sizeof(u32)));
	return ret;
};

glb_chunk_total_size ::= func(c : glb_chunk -> u64)
{
	return __sizeof(u32) + __sizeof(u32) + (c.length);
};

glb_populate_scenes_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	j : u64 mut;
	// scenes
	(g->default_scene) = json_number_get_integer(deref json_object_find_fieldz(g->json, "scene"))@u64;
	scenes_field ::= json_object_find_fieldz(g->json, "scenes");
	g->scenes_count = json_array_length(deref scenes_field);
	g->scenes = arena_alloc(a, __sizeof(glb_scene) * (g->scenes_count));
	for(i = 0, i < (g->scenes_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref scenes_field, i);
		namefield ::= json_object_find_fieldz(deref cur, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(namefield != zero)
		{
			name = json_string_data(deref namefield);
			name_len = json_string_length(deref namefield);
		}
		node_indices_field ::= json_object_find_fieldz(deref cur, "nodes");
		node_indices : u64 mut? mut := zero;
		node_indices_count : u64 mut := zero;
		if(node_indices_field != zero)
		{
			node_indices_count = json_array_length(deref node_indices_field)@u64;
			node_indices = arena_alloc(a, __sizeof(u64) * node_indices_count);
			for(j = 0, j < node_indices_count, j = j + 1)
			{
				deref(node_indices#j) = json_number_get_integer(deref json_array_get_element(deref node_indices_field, j))@_;
			}
		}
	
		deref(g->scenes # i) = glb_scene
		{
			.name := name;
			.name_len := name_len;
			.node_indices := node_indices;
			.node_indices_count := node_indices_count;
		};
	}
};

glb_populate_nodes_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	j : u64 mut;
	nodes_field ::= json_object_find_fieldz(g->json, "nodes");
	g->nodes_count = json_array_length(deref nodes_field);
	g->nodes = arena_alloc(a, __sizeof(glb_node) * (g->nodes_count));
	for(i = 0, i < (g->nodes_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref nodes_field, i);
		mesh_idx : u64 mut := glb_badidx;
		mesh_field ::= json_object_find_fieldz(deref cur, "mesh");
		if(mesh_field != zero)
		{
			mesh_idx = json_number_get_integer(deref mesh_field)@_;
		}

		skin_idx : u64 mut := glb_badidx;
		skin_field ::= json_object_find_fieldz(deref cur, "skin");
		if(skin_field != zero)
		{
			skin_idx = json_number_get_integer(deref skin_field)@_;
		}

		name_field ::= json_object_find_fieldz(deref cur, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(name_field != zero)
		{
			name = json_string_data(deref name_field);
			name_len = json_string_length(deref name_field);
		}

		matrix : f32 mut[16] mut;
		translate : f32 mut[3] := zero;
		rotate : f32 mut[4] := f32[4]{0.0; 0.0; 0.0; 1.0;};
		scale : f32 mut[3] := f32[3]{1.0; 1.0; 1.0;};
		transform : glb_node_transform mut := zero;
	
		matrix_field ::= json_object_find_fieldz(deref cur, "matrix");
		if(matrix_field != zero)
		{
			transform = (glb_node_transform.matrix);
			for(j = 0, j < 16, j = j + 1)
			{
				deref(matrix # j) = json_number_get_float(deref json_array_get_element(deref matrix_field, j))@_;
			}
		}
		else
		{
			transform = (glb_node_transform.trs);
		}
		translate_field ::= json_object_find_fieldz(deref cur, "translation");
		if(translate_field != zero)
		{
			for(j = 0, j < 3, j = j + 1)
			{
				deref(translate # j) = json_number_get_float(deref json_array_get_element(deref translate_field, j))@_;
			}
		}
		rotate_field ::= json_object_find_fieldz(deref cur, "rotation");
		if(rotate_field != zero)
		{
			for(j = 0, j < 4, j = j + 1)
			{
				deref(rotate # j) = json_number_get_float(deref json_array_get_element(deref rotate_field, j))@_;
			}
		}
		scale_field ::= json_object_find_fieldz(deref cur, "scale");
		if(scale_field != zero)
		{
			for(j = 0, j < 3, j = j + 1)
			{
				deref(scale # j) = json_number_get_float(deref json_array_get_element(deref scale_field, j))@_;
			}
		}

		children_field ::= json_object_find_fieldz(deref cur, "children");
		children : u64 mut? mut := zero;
		children_count : u64 mut := zero;
		if(children_field != zero)
		{
			children_count = json_array_length(deref children_field);
			children = arena_alloc(a, __sizeof(deref children) * children_count);
			for(j = 0, j < children_count, j = j + 1)
			{
				deref(children # j) = json_number_get_integer(deref json_array_get_element(deref children_field, j))@_;
			}
		}

		deref(g->nodes # i) = glb_node
		{
			.name := name;
			.name_len := name_len;
			.mesh_idx := mesh_idx;
			.skin_idx := skin_idx;
			.transform := transform;
			.matrix := matrix;
			.translate := translate;
			.rotate := rotate;
			.scale := scale;
			.children := children;
			.children_count := children_count;
		};
	}
};

glb_populate_views_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	views_field ::= json_object_find_fieldz(g->json, "bufferViews");
	g->views_count = json_array_length(deref views_field);
	g->views = arena_alloc(a, __sizeof(glb_view) * (g->views_count));
	for(i = 0, i < (g->views_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref views_field, i);

		buf_idx ::= json_number_get_integer(deref json_object_find_fieldz(deref cur, "buffer"));
		if(buf_idx != 0)
		{
			putzstr("detected bufferView not pointed at buffer 0, which is not supported");
			__debugbreak();
		}

		off_field ::= json_object_find_fieldz(deref cur, "byteOffset");
		offset : u64 mut := 0;	
		if(off_field != zero)
		{
			offset = json_number_get_integer(deref off_field)@_;
		}

		len ::= json_number_get_integer(deref json_object_find_fieldz(deref cur, "byteLength"));

		stride_field ::= json_object_find_fieldz(deref cur, "byteStride");
		stride : u64 mut := glb_badidx;	
		if(stride_field != zero)
		{
			stride = json_number_get_integer(deref stride_field)@_;
		}

		target_field ::= json_object_find_fieldz(deref cur, "target");
		target : u64 mut := glb_badidx;	
		if(target_field != zero)
		{
			target = json_number_get_integer(deref target_field)@_;
		}

		name_field ::= json_object_find_fieldz(deref cur, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(name_field != zero)
		{
			name = json_string_data(deref name_field);
			name_len = json_string_length(deref name_field);
		}

		deref(g->views # i) = glb_view
		{
			.offset := offset;
			.length := len@_;
			.stride := stride;
			.target := target;
			.name := name;
			.name_len := name_len;
		};
	}
};

glb_populate_accessors_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	accessors_field ::= json_object_find_fieldz(g->json, "accessors");
	g->accessors_count = json_array_length(deref accessors_field);
	g->accessors = arena_alloc(a, __sizeof(glb_accessor) * (g->accessors_count));
	for(i = 0, i < (g->accessors_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref accessors_field, i);
		if(json_object_find_fieldz(deref cur, "sparse") != zero)
		{
			putzstr("sparse accessors in a GLB are not supported");
			__debugbreak();
			return;
		}

		type_field ::= json_object_find_fieldz(deref cur, "type");
		offset_field ::= json_object_find_fieldz(deref cur, "byteOffset");
		offset : u64 mut := 0;
		if(offset_field != zero)
		{
			offset = json_number_get_integer(deref offset_field)@_;
		}

		deref(g->accessors # i) = glb_accessor
		{
			.view_idx := json_number_get_integer(deref json_object_find_fieldz(deref cur, "bufferView"))@_;
			.offset := offset;
			.component_type := json_number_get_integer(deref json_object_find_fieldz(deref cur, "componentType"))@_;
			.count := json_number_get_integer(deref json_object_find_fieldz(deref cur, "count"))@_;
			.type := json_string_data(deref type_field);
			.type_len := json_string_length(deref type_field);
		};
	}
};

glb_populate_meshes_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	j : u64 mut;
	meshes_field ::= json_object_find_fieldz(g->json, "meshes");
	g->meshes_count = json_array_length(deref meshes_field);
	g->meshes = arena_alloc(a, __sizeof(glb_mesh) * (g->meshes_count));
	for(i = 0, i < (g->meshes_count), i = i + 1)
	{
		curmesh ::= json_array_get_element(deref meshes_field, i);
		name_field ::= json_object_find_fieldz(deref curmesh, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(name_field != zero)
		{
			name = json_string_data(deref name_field);
			name_len = json_string_length(deref name_field);
		}
		
		primitives_count : u64 mut := 0;
		primitives : glb_mesh_primitive mut? mut := zero;
		primitives_field ::= json_object_find_fieldz(deref curmesh, "primitives");
		if(primitives_field != zero)
		{	
			primitives_count = json_array_length(deref primitives_field);
			primitives = arena_alloc(a, __sizeof(glb_mesh_primitive) * primitives_count);
			// todo: populate primitive values
			for(j = 0, j < primitives_count, j = j + 1)
			{
				deref(primitives # j) = glb_populate_primitive_from_json(deref(json_array_get_element(deref primitives_field, j)));
			}
		}

		deref(g->meshes # i) = glb_mesh
		{
			.name := name;
			.name_len := name_len;
			.primitives := primitives;
			.primitives_count := primitives_count;
		};
	}
};

glb_populate_materials_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	j : u64 mut;
	materials_field ::= json_object_find_fieldz(g->json, "materials");
	g->materials_count = json_array_length(deref materials_field);
	g->materials = arena_alloc(a, __sizeof(glb_material) * (g->materials_count));
	for(i = 0, i < (g->materials_count), i = i + 1)
	{
		curmaterial ::= json_array_get_element(deref materials_field, i);
		name_field ::= json_object_find_fieldz(deref curmaterial, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(name_field != zero)
		{
			name = json_string_data(deref name_field);
			name_len = json_string_length(deref name_field);
		}

		pbr : glb_pbr_metallic_roughness mut := zero;
		pbr_field ::= json_object_find_fieldz(deref curmaterial, "pbrMetallicRoughness");
		if(pbr_field == zero)
		{
			putzstr("detected glb with a material that is imssing its pbrMetallicRoughness field. these are not supported");
			__debugbreak();
		}
		pbr.base_colour_texture = glb_populate_texture_from_json(deref json_object_find_fieldz(deref pbr_field, "baseColorTexture"));	

		pbr.base_colour_factor = f32[4]{1.0; 1.0; 1.0; 1.0;};
		base_colour_factor_field ::= json_object_find_fieldz(deref pbr_field, "baseColorFactor");
		if(base_colour_factor_field != zero)
		{
			for(j = 0, j < 4, j = j + 1)
			{
				deref(pbr.base_colour_factor # j) = json_number_get_float(deref json_array_get_element(deref base_colour_factor_field, j))@_;
			}
		}

		metallic_roughness_field ::= json_object_find_fieldz(deref pbr_field, "metallicRoughnessTexture");
		pbr.has_metallic_roughness_texture = false;
		if(metallic_roughness_field != zero)
		{
			pbr.metallic_roughness_texture = glb_populate_texture_from_json(deref metallic_roughness_field);
			pbr.has_metallic_roughness_texture = true;
		}
		pbr.metallic_factor = json_number_get_float(deref json_object_find_fieldz(deref pbr_field, "metallicFactor"))@_;
		pbr.roughness_factor = json_number_get_float(deref json_object_find_fieldz(deref pbr_field, "roughnessFactor"))@_;

		normal_texture_field ::= json_object_find_fieldz(deref curmaterial, "normalTexture");
		normal_texture : glb_texture mut := zero;
		has_normal_texture : bool mut := false;
		if(normal_texture_field != zero)
		{
			normal_texture = glb_populate_texture_from_json(deref normal_texture_field);
			has_normal_texture = true;
		}

		occlusion_texture_field ::= json_object_find_fieldz(deref curmaterial, "occlusionTexture");
		occlusion_texture : glb_texture mut := zero;
		has_occlusion_texture : bool mut := false;
		if(occlusion_texture_field != zero)
		{
			occlusion_texture = glb_populate_texture_from_json(deref occlusion_texture_field);
			has_occlusion_texture = true;
		}

		emissive_texture_field ::= json_object_find_fieldz(deref curmaterial, "emissiveTexture");
		emissive_texture : glb_texture mut := zero;
		has_emissive_texture : bool mut := false;
		if(emissive_texture_field != zero)
		{
			emissive_texture = glb_populate_texture_from_json(deref emissive_texture_field);
			has_emissive_texture = true;
		}
		emissive_factor : f32 mut[4] := zero;
		emissive_factor_field ::= json_object_find_fieldz(deref curmaterial, "emissiveFactor");
		if(emissive_factor_field != zero)
		{
			for(j = 0, j < 4, j = j + 1)
			{
				deref(emissive_factor # j) = json_number_get_float(deref json_array_get_element(deref emissive_factor_field, j))@_;
			}
		}
	
		
		deref(g->materials # i) = glb_material
		{
			.name := name;
			.name_len := name_len;
			.pbr_metallic_roughness := pbr;
			.normal_texture := normal_texture;
			.has_normal_texture := has_normal_texture;
			.occlusion_texture := occlusion_texture;
			.has_occlusion_texture := has_occlusion_texture;
			.emissive_texture := emissive_texture;
			.emissive_factor := emissive_factor;
			.has_emissive_texture := has_emissive_texture;
		};
	}
};

glb_populate_texture_from_json ::= func(texture_field : json_data -> glb_texture)
{
	ret : glb_texture mut := zero;
	ret.scale = 1.0;
	
	ret.index = json_number_get_integer(deref json_object_find_fieldz(texture_field, "index"))@_;

	texcoord_field ::= json_object_find_fieldz(texture_field, "texCoord");
	if(texcoord_field != zero)
	{
		ret.texCoord = json_number_get_integer(deref texcoord_field)@_;
	}
	
	scale_field ::= json_object_find_fieldz(texture_field, "scale");
	if(scale_field != zero)
	{
		ret.scale = json_number_get_float(deref scale_field)@_;
	}
	return ret;
};

glb_populate_primitive_from_json ::= func(primitive_field : json_data -> glb_mesh_primitive)
{
	// lets do the hard part - attribs
	attribs_field ::= json_object_find_fieldz(primitive_field, "attributes");

	position : u64 mut := glb_badidx;
	normal : u64 mut := glb_badidx;
	tangent : u64 mut := glb_badidx;
	texcoord ::= u64 mut[4]{glb_badidx; glb_badidx; glb_badidx; glb_badidx;};
	color ::= u64 mut[4]{glb_badidx; glb_badidx; glb_badidx; glb_badidx;};
	joint ::= u64 mut[4]{glb_badidx; glb_badidx; glb_badidx; glb_badidx;};
	weight ::= u64 mut[4]{glb_badidx; glb_badidx; glb_badidx; glb_badidx;};

	position_field ::= json_object_find_fieldz(deref attribs_field, "POSITION");
	if(position_field != zero)
	{
		position = json_number_get_integer(deref position_field)@_;
	}
	normal_field ::= json_object_find_fieldz(deref attribs_field, "NORMAL");
	if(normal_field != zero)
	{
		normal = json_number_get_integer(deref normal_field)@_;
	}
	tangent_field ::= json_object_find_fieldz(deref attribs_field, "TANGENT");
	if(tangent_field != zero)
	{
		tangent = json_number_get_integer(deref tangent_field)@_;
	}
	texcoord0_field ::= json_object_find_fieldz(deref attribs_field, "TEXCOORD_0");
	if(texcoord0_field != zero)
	{
		deref(texcoord # 0) = json_number_get_integer(deref texcoord0_field)@_;
	}
	texcoord1_field ::= json_object_find_fieldz(deref attribs_field, "TEXCOORD_1");
	if(texcoord1_field != zero)
	{
		deref(texcoord # 1) = json_number_get_integer(deref texcoord1_field)@_;
	}
	texcoord2_field ::= json_object_find_fieldz(deref attribs_field, "TEXCOORD_2");
	if(texcoord2_field != zero)
	{
		deref(texcoord # 2) = json_number_get_integer(deref texcoord2_field)@_;
	}
	texcoord3_field ::= json_object_find_fieldz(deref attribs_field, "TEXCOORD_3");
	if(texcoord3_field != zero)
	{
		deref(texcoord # 3) = json_number_get_integer(deref texcoord3_field)@_;
	}
	color0_field ::= json_object_find_fieldz(deref attribs_field, "COLOR_0");
	if(color0_field != zero)
	{
		deref(color # 0) = json_number_get_integer(deref color0_field)@_;
	}
	color1_field ::= json_object_find_fieldz(deref attribs_field, "COLOR_1");
	if(color1_field != zero)
	{
		deref(color # 1) = json_number_get_integer(deref color1_field)@_;
	}
	color2_field ::= json_object_find_fieldz(deref attribs_field, "COLOR_2");
	if(color2_field != zero)
	{
		deref(color # 2) = json_number_get_integer(deref color2_field)@_;
	}
	color3_field ::= json_object_find_fieldz(deref attribs_field, "COLOR_3");
	if(color3_field != zero)
	{
		deref(color # 3) = json_number_get_integer(deref color3_field)@_;
	}
	joint0_field ::= json_object_find_fieldz(deref attribs_field, "JOINTS_0");
	if(joint0_field != zero)
	{
		deref(joint # 0) = json_number_get_integer(deref joint0_field)@_;
	}
	joint1_field ::= json_object_find_fieldz(deref attribs_field, "JOINTS_1");
	if(joint1_field != zero)
	{
		deref(joint # 1) = json_number_get_integer(deref joint1_field)@_;
	}
	joint2_field ::= json_object_find_fieldz(deref attribs_field, "JOINTS_2");
	if(joint2_field != zero)
	{
		deref(joint # 2) = json_number_get_integer(deref joint2_field)@_;
	}
	joint3_field ::= json_object_find_fieldz(deref attribs_field, "JOINTS_3");
	if(joint3_field != zero)
	{
		deref(joint # 3) = json_number_get_integer(deref joint3_field)@_;
	}

	weight0_field ::= json_object_find_fieldz(deref attribs_field, "WEIGHTS_0");
	if(weight0_field != zero)
	{
		deref(weight # 0) = json_number_get_integer(deref weight0_field)@_;
	}
	weight1_field ::= json_object_find_fieldz(deref attribs_field, "WEIGHTS_1");
	if(weight1_field != zero)
	{
		deref(weight # 1) = json_number_get_integer(deref weight1_field)@_;
	}
	weight2_field ::= json_object_find_fieldz(deref attribs_field, "WEIGHTS_2");
	if(weight2_field != zero)
	{
		deref(weight # 2) = json_number_get_integer(deref weight2_field)@_;
	}
	weight3_field ::= json_object_find_fieldz(deref attribs_field, "WEIGHTS_3");
	if(weight3_field != zero)
	{
		deref(weight # 3) = json_number_get_integer(deref weight3_field)@_;
	}

	indices : u64 mut := glb_badidx;
	material : u64 mut := glb_badidx;
	GLTF_MODE_TRIANGLES ::= 4;
	mode : u64 mut := GLTF_MODE_TRIANGLES;
	// todo: targets

	return glb_mesh_primitive
	{
		.mode := mode;
		.indices := indices;
		.position_attrib := position;
		.normal_attrib := normal;
		.tangent_attrib := tangent;
		.texcoord_attribs := texcoord;
		.color_attribs := color;
		.joint_attribs := joint;
		.weight_attribs := weight;
	};
};

glb_verify_single_buffer ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	buffers_field ::= json_object_find_fieldz(g->json, "buffers");
	if(buffers_field == zero)
	{
		return;
	}
	buffers_count ::= json_array_length(deref buffers_field);
	for(i = 0, i < buffers_count, i = i + 1)
	{
		cur ::= json_array_get_element(deref buffers_field, i);
		if(json_object_find_fieldz(deref cur, "uri") != zero)
		{
			putzstr("detected glb with a buffer containing a uri. these are not supported");
			__debugbreak();
		}
	}
	if(buffers_count > 1)
	{
		putzstr("glbs with more than one buffer are not supported.");
		__debugbreak();
	}
	
};

glb_populate_fields_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	glb_populate_scenes_from_json(g, a);
	glb_populate_nodes_from_json(g, a);
	glb_verify_single_buffer(g, a);
	glb_populate_views_from_json(g, a);
	glb_populate_accessors_from_json(g, a);
	glb_populate_meshes_from_json(g, a);
	glb_populate_materials_from_json(g, a);
};

glb_do_parse ::= func(buf : u8?, max_len : u64, a : arena mut? -> glb_parse_state)
{
	ret ::= zero@glb_parse_state mut;
	ret.hdr = deref((buf)@glb_header?);
	len ::= ret.hdr.length@u64;
	glb_validate_hdr(ref ret);
	offset : u64 mut := __sizeof(glb_header);

	json_chunk : glb_chunk mut;
	while(offset < len)
	{
		putzstr("offset: ");
		putuint(offset);
		putzstr(", len: ");
		putuint(len);
		putchar(10);

		chunk ::= glb_parse_chunk(buf # offset);
		if(offset == __sizeof(glb_header))
		{
			// this is the first chunk. guaranteed to be the json chunk
			ret.result.json = json_parse_buffer_named("<glb json chunk>", chunk.data, chunk.length@_, a);
			putzstr("json chunk size: ");
			putuint(chunk.length@_);
			putchar(10);
		}
		else
		{
			if(ret.result.bin.data == zero)
			{
				// ensure that the chunk header is BIN\0
				if(!streql_n(ref(chunk.type)@u8?, "BIN", 3))
				{
					putzstr("the non-first chunk was not a BIN chunk. its header was:");
					putbytes(ref(chunk.type)@u8?, 4);
					putchar(10);
					__debugbreak();
				}
				ret.result.bin = glb_binary_chunk
				{
					.data := chunk.data;
					.length := chunk.length@_;
				};
			}
			else
			{
				// a 3rd chunk has appeared... just ignore it
				putzstr("warning: more than 2 chunks detected in glb. ignoring chunk of type: ");
				putchar('"');
				putbytes(ref(chunk.type)@u8?, 4);
				putchar('"');
			}
		}
		offset = (offset + glb_chunk_total_size(chunk));
	}

	glb_populate_fields_from_json(ref(ret.result), a);
	return ret;
};

glb_parse_state ::= struct
{
	result : glb;
	hdr : glb_header;
};

glb_header ::= struct
{
	magic : u32;
	version : u32;
	length : u32;
};

glb_chunk ::= struct
{
	length : u32;
	type : u32;
	data : u8?;
};

glb_validate_hdr ::= func(s : glb_parse_state mut? -> v0)
{
	hdr ::= s->hdr;
	if(hdr.magic != 0x46546C67)
	{
		glb_parse_error(s, "invalid glb header - magic mismatch");
	}
	if(hdr.version != 2)
	{
		glb_parse_error(s, "invalid glb header - must be version 2");
	}
};

glb_parse_error ::= func(s : glb_parse_state mut?, errmsg : u8? -> v0)
{
	s->result.errmsg = errmsg;
};

glb_parse_chunk ::= func(buf : u8? -> glb_chunk)
{
	ret ::= deref((buf)@glb_chunk mut?);
	// directly after length + type
	ret.data = (buf # (__sizeof(u32) + __sizeof(u32)));
	return ret;
};

glb_chunk_total_size ::= func(c : glb_chunk -> u64)
{
	return __sizeof(u32) + __sizeof(u32) + (c.length);
};

glb_populate_scenes_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	j : u64 mut;
	// scenes
	(g->default_scene) = json_number_get_integer(deref json_object_find_fieldz(g->json, "scene"))@u64;
	scenes_field ::= json_object_find_fieldz(g->json, "scenes");
	g->scenes_count = json_array_length(deref scenes_field);
	g->scenes = arena_alloc(a, __sizeof(glb_scene) * (g->scenes_count));
	for(i = 0, i < (g->scenes_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref scenes_field, i);
		namefield ::= json_object_find_fieldz(deref cur, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(namefield != zero)
		{
			name = json_string_data(deref namefield);
			name_len = json_string_length(deref namefield);
		}
		node_indices_field ::= json_object_find_fieldz(deref cur, "nodes");
		node_indices : u64 mut? mut := zero;
		node_indices_count : u64 mut := zero;
		if(node_indices_field != zero)
		{
			node_indices_count = json_array_length(deref node_indices_field)@u64;
			node_indices = arena_alloc(a, __sizeof(u64) * node_indices_count);
			for(j = 0, j < node_indices_count, j = j + 1)
			{
				deref(node_indices#j) = json_number_get_integer(deref json_array_get_element(deref node_indices_field, j))@_;
			}
		}
	
		deref(g->scenes # i) = glb_scene
		{
			.name := name;
			.name_len := name_len;
			.node_indices := node_indices;
			.node_indices_count := node_indices_count;
		};
	}
};

glb_populate_nodes_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	nodes_field ::= json_object_find_fieldz(g->json, "nodes");
	g->nodes_count = json_array_length(deref nodes_field);
	g->nodes = arena_alloc(a, __sizeof(glb_node) * (g->nodes_count));
	for(i = 0, i < (g->nodes_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref nodes_field, i);
		mesh_idx : u64 mut := glb_badidx;
		mesh_field ::= json_object_find_fieldz(deref cur, "mesh");
		if(mesh_field != zero)
		{
			mesh_idx = json_number_get_integer(deref mesh_field)@_;
		}

		skin_idx : u64 mut := glb_badidx;
		skin_field ::= json_object_find_fieldz(deref cur, "skin");
		if(skin_field != zero)
		{
			skin_idx = json_number_get_integer(deref skin_field)@_;
		}

		name_field ::= json_object_find_fieldz(deref cur, "name");
		name : u8? mut := zero;
		name_len : u64 mut := zero;
		if(name_field != zero)
		{
			name = json_string_data(deref name_field);
			name_len = json_string_length(deref name_field);
		}

		deref(g->nodes # i) = glb_node
		{
			.name := name;
			.name_len := name_len;
			.mesh_idx := mesh_idx;
			.skin_idx := skin_idx;
		};
	}
};

glb_populate_buffers_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	i : u64 mut;
	buffers_field ::= json_object_find_fieldz(g->json, "buffers");
	g->buffers_count = json_array_length(deref buffers_field);
	g->buffers = arena_alloc(a, __sizeof(glb_buffer) * (g->buffers_count));
	for(i = 0, i < (g->buffers_count), i = i + 1)
	{
		cur ::= json_array_get_element(deref buffers_field, i);
		
		//deref(g->buffers # i) = glb_buffer
		//{
		//	.ptr := 
		//};
	}
	
};

glb_populate_fields_from_json ::= func(g : glb mut?, a : arena mut? -> v0)
{
	glb_populate_scenes_from_json(g, a);
	glb_populate_nodes_from_json(g, a);
};

glb_do_parse ::= func(buf : u8?, len : u64, a : arena mut? -> glb_parse_state)
{
	ret ::= zero@glb_parse_state mut;
	ret.hdr = deref((buf)@glb_header?);
	glb_validate_hdr(ref ret);
	offset : u64 mut := __sizeof(glb_header);

	json_chunk : glb_chunk mut;
	while(offset < len)
	{
		chunk ::= glb_parse_chunk(buf # offset);
		if(offset == __sizeof(glb_header))
		{
			// this is the first chunk. guaranteed to be the json chunk
			ret.result.json = json_parse_buffer_named("<glb json chunk>", chunk.data, chunk.length@_, a);
			putzstr("json chunk size: ");
			putuint(chunk.length@_);
			putchar(10);
		}
		else
		{
			if(ret.result.bin.data == zero)
			{
				// ensure that the chunk header is BIN\0
				if(!streql_n(ref(chunk.type)@u8?, "BIN", 3))
				{
					putzstr("the non-first chunk was not a BIN chunk. its header was:");
					putbytes(ref(chunk.type)@u8?, 4);
					putchar(10);
					__debugbreak();
				}
				ret.result.bin = glb_binary_chunk
				{
					.data := chunk.data;
					.length := chunk.length@_;
				};
			}
			else
			{
				// a 3rd chunk has appeared... just ignore it
				putzstr("warning: more than 2 chunks detected in glb. ignoring chunk of type: ");
				putchar('"');
				putbytes(ref(chunk.type)@u8?, 4);
				putchar('"');
			}
		}
		offset = (offset + glb_chunk_total_size(chunk));
	}

	glb_populate_fields_from_json(ref(ret.result), a);
	return ret;
};

glb_badidx : u64 static := -1;

glb ::= struct
{
	header : glb_header;
	errmsg : u8?;
	json : json_data;
	bin : glb_binary_chunk;

	default_scene : u64;
	scenes : glb_scene mut?;
	scenes_count : u64;

	nodes : glb_node mut?;
	nodes_count : u64;

	views : glb_view mut?;
	views_count : u64;

	accessors : glb_accessor mut?;
	accessors_count : u64;

	meshes : glb_mesh mut?;
	meshes_count : u64;

	materials : glb_material mut?;
	materials_count : u64;

	cameras : glb_camera mut?;
	cameras_count : u64;

	samplers : glb_sampler mut?;
	samplers_count : u64;

	skins : glb_skin mut?;
	skins_count : u64;

	animations : glb_animation mut?;
	animations_count : u64;
};

glb_header ::= struct
{
	magic : u32;
	version : u32;
	length : u32;
};

glb_view ::= struct
{
	// optional - default zero
	offset : u64;
	length : u64;
	// optional - default badidx
	stride : u64;
	// optional - default badidx
	target : u64;
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
};

glb_binary_chunk ::= struct
{
	data : u8?;
	length : u64;
};

glb_scene ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default zero
	node_indices : u64?;
	// optional - default zero
	node_indices_count : u64;
};

glb_node_transform ::= enum
{
	.matrix := 1;
	.trs := 2;
};

glb_node ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default badidx
	mesh_idx : u64;
	// optional - default badidx
	skin_idx : u64;
	// optional - default trs
	transform : glb_node_transform;
	// optional - undefined if transform != .matrix
	matrix : f32 mut[16];
	// optional - undefined if transform != .trs
	translate : f32 mut[3];
	// optional - undefined if transform != .trs
	rotate : f32 mut[4];
	// optional - undefined if transform != .trs
	scale : f32 mut[3];
	// optional - default zero
	children : u64 mut? mut;
	// optional - default zero
	children_count : u64;
};

glb_accessor ::= struct
{
	// mandatory
	view_idx : u64;
	// optional - default 0
	offset : u64;
	// mandatory
	component_type: u64;
	// mandatory
	count : u64;
	// mandatory
	type : u8?;
	// mandatory
	type_len : u64;
};

glb_mesh ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default zero
	primitives : glb_mesh_primitive mut?;
	// optional - default zero
	primitives_count : u64;
};

glb_mesh_primitive ::= struct
{
	// optional - default GLTF_MODE_TRIANGLES
	mode : glb_mesh_primitive_mode;
	// optional - default badidx
	indices : u64;
	// optional - default badidx
	position_attrib : u64;
	// optional - default badidx
	normal_attrib : u64;
	// optional - default badidx
	tangent_attrib : u64;
	// optional - default badidx[4]
	texcoord_attribs : u64 mut[4];
	// optional - default badidx[4]
	color_attribs : u64 mut[4];
	// optional - default badidx[4]
	joint_attribs : u64 mut[4];
	// optional - default badidx[4]
	weight_attribs : u64 mut[4];
};

glb_mesh_primitive_mode ::= enum
{
	.points := 0;
	.lines := 1;
	.line_loop := 2;
	.line_strip := 3;
	.triangles := 4;
	.triangle_strip := 5;
	.triangle_fan := 6;
};

glb_material ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default as required by spec
	pbr_metallic_roughness : glb_pbr_metallic_roughness;
	// optional - ignore if !has_normal_texture
	normal_texture : glb_material_texture;
	has_normal_texture : bool;
	// optional - ignore if !has_occlusion_texture
	occlusion_texture : glb_material_texture;
	has_occlusion_texture : bool;
	// optional - ignore if !has_emissive_texture
	emissive_texture : glb_material_texture;
	has_emissive_texture : bool;
	// optional - default zero[4]
	emissive_factor : f32 mut[4];
};

glb_pbr_metallic_roughness ::= struct
{
	// optional - ignore if !has_base_colour_texture
	base_colour_texture : glb_material_texture;
	has_base_colour_texture : bool;
	// optional - default 1.0[4]
	base_colour_factor : f32 mut[4];
	// optional - ignore if !has_metallic_roughness_texture
	metallic_roughness_texture : glb_material_texture;
	has_metallic_roughness_texture : bool;
	// optional - default 1.0
	metallic_factor : f32;
	// optional - default 1.0
	roughness_factor : f32;
};

glb_camera ::= struct
{
	// mandatory
	type : glb_camera_type;
	// optional - ignore if type == .orthographic
	perspective : glb_perspective;
	// optional - ignore if type == .perspective
	orthographic : glb_orthographic;
};

glb_sampler ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default .nearest
	mag_filter : glb_image_mag_filter;
	// optional - default .nearest
	min_filter : glb_image_min_filter;
	// optional - default .repeat
	wrap_u : glb_image_address_mode; // aka s
	// optional - default .repeat
	wrap_v : glb_image_address_mode; // aka t
};

glb_skin ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default badidx
	skeleton : u64;
	// mandatory
	joints : u64 mut?;	
	// mandatory
	joints_count : u64;
	// optional - default badidx
	inverse_bind_matrices : u64;
};

glb_animation ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// mandatory
	channels : glb_animation_channel mut?;
	// mandatory
	channels_count : u64;
	// mandatory
	samplers : glb_animation_sampler mut?;
	// mandatory
	samplers_count : u64;
};

glb_animation_channel ::= struct
{
	// mandatory
	sampler_idx : u64;
	// mandatory
	target : glb_animation_channel_target;
};

glb_animation_channel_target ::= struct
{
	// mandatory
	node_idx : u64;
	// mandatory
	path : glb_animation_channel_target_path;
};

glb_animation_sampler ::= struct
{
	// mandatory
	timestamps_accessor_idx : u64;
	// optional - default .linear
	interpolation : glb_animation_sampler_interpolation;
	// mandatory
	output_values_accessor_idx : u64;
};

glb_animation_channel_target_path ::= enum
{
	.translation := 1;
	.rotation := 2;
	.scale := 3;
	.weights := 4;
};

glb_animation_sampler_interpolation ::= enum
{
	.linear := 0;
	.step := 1;
	.cubic_spline := 2;
};

glb_image_min_filter ::= enum
{
	.nearest := 0x2600;
	.linear := 0x2601;
	.nearest_mipmap_nearest := 0x2700;
	.linear_mipmap_nearest := 0x2701;
	.nearest_mipmap_linear := 0x2702;
	.linear_mipmap_linear := 0x2703;
};

glb_image_mag_filter ::= enum
{
	.nearest := 0x2600;
	.linear := 0x2601;
};

glb_image_address_mode ::= enum
{
	.clamp_to_edge := 0x812f;
	.clamp_to_border := 0x812d;
	.mirrored_repeat := 0x8370;
	.repeat := 0x2901;
	.mirror_clamp_to_edge := 0x8743;
};

glb_material_texture ::= struct
{
	index : u64;
	texCoord : u64;
	scale : f32;
};

glb_camera_type ::= enum
{
	.perspective := 0;
	.orthographic := 1;
};

glb_perspective ::= struct
{
	aspect_ratio : f32;
	yfov : f32;
	znear : f32;
	has_zfar : bool;
	zfar : f32;
};

glb_orthographic ::= struct
{
	xmag : f32;
	ymag : f32;
	znear : f32;
	zfar : f32;
};

glb_scene_verbose_print ::= func(s : glb_scene -> v0)
{
	putbytes(s.name, s.name_len);
	putzstr(": [");
	i : u64 mut;
	for(i = 0, i < (s.node_indices_count), i = i + 1)
	{
		putuint(deref(s.node_indices # i));
		if(i < (s.node_indices_count - 1))
		{
			putchar(' ');
		}
	}
	putzstr("]");
};

glb_node_verbose_print ::= func(n : glb_node -> v0)
{
	putbytes(n.name, n.name_len);
	putzstr(" [mesh: ");
	putuint(n.mesh_idx);
	putzstr(", skin: ");
	putuint(n.skin_idx);
	putzstr("], ");
	putzstr(__enumname(n.transform));
	putzstr(": [");
	putchar(10);

	i : u64 mut;
	j : u64 mut;
	if(n.transform == (glb_node_transform.matrix))
	{
		mat ::= n.matrix;
		for(i = 0, i < 4, i = i + 1)
		{
			putchar(9);
			putchar('|');
			for(j = 0, j < 4, j = j + 1)
			{
				putfloat(deref(mat # ((i * 3) + j)));
				putzstr("   ");
			}
			putchar('|');
			putchar(10);
		}
		putchar(10);
	}
	else
	{
		t ::= n.translate;
		r ::= n.rotate;
		s ::= n.scale;
		putchar(9);
		putzstr("t: [");
		for(i = 0, i < 3, i = i + 1)
		{
			putfloat(deref(t # i));
			if(i < 2)
			{
				putzstr(", ");
			}
		}
		putzstr("]");
		putchar(10);

		putchar(9);
		putzstr("r: [");
		for(i = 0, i < 4, i = i + 1)
		{
			putfloat(deref(r # i));
			if(i < 3)
			{
				putzstr(", ");
			}
		}
		putzstr("]");
		putchar(10);

		putchar(9);
		putzstr("s: [");
		for(i = 0, i < 3, i = i + 1)
		{
			putfloat(deref(s # i));
			if(i < 2)
			{
				putzstr(", ");
			}
		}
		putzstr("]]");
		putchar(10);
		if(n.children_count > 0)
		{
			putzstr(", children: [");
			putchar(10);
			for(i = 0, i < (n.children_count), i = i + 1)
			{
				putchar(9);
				if(i < (n.children_count - 1))
				{
					putuint(deref(n.children # i));
					putchar(10);
				}
			}
			putzstr("]");
		}
	}
	
};

glb_view_verbose_print ::= func(n : glb_view -> v0)
{
	if(n.name != zero)
	{
		putbytes(n.name, n.name_len);
	}
	else
	{
		putzstr("<unnamed view>");
	}
	putzstr(" [offset: ");
	putuint(n.offset);
	putzstr(", length: ");
	putuint(n.length);
	putzstr(", stride: ");
	putuint(n.stride);
	putzstr(", target: ");
	putuint(n.target);
	putzstr("]");
};

glb_mesh_verbose_print ::= func(m : glb_mesh -> v0)
{
	if(m.name != zero)
	{
		putbytes(m.name, m.name_len);
	}
	else
	{
		putzstr("<unnamed mesh>");
	}
	i : u64 mut;
	for(i = 0, i < (m.primitives_count), i = i + 1)
	{
		p ::= deref(m.primitives # i);
		putchar(10);
		putchar(9);
		putzstr("[mode: ");
		putzstr(__enumname(p.mode));
		putzstr(", indices: ");
		putuint(p.indices);
		putzstr(", attribs: {");
		putchar(10);
		putchar(9);putchar(9);
		putzstr("position: ");
		putuint(p.position_attrib);

		putchar(10);
		putchar(9);putchar(9);
		putzstr("normal: ");
		putuint(p.normal_attrib);

		putchar(10);
		putchar(9);putchar(9);
		putzstr("tangent: ");
		putuint(p.tangent_attrib);

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord0: ");
		putuint(deref(p.texcoord_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord1: ");
		putuint(deref(p.texcoord_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord2: ");
		putuint(deref(p.texcoord_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord3: ");
		putuint(deref(p.texcoord_attribs # 3));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color0: ");
		putuint(deref(p.color_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color1: ");
		putuint(deref(p.color_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color2: ");
		putuint(deref(p.color_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color3: ");
		putuint(deref(p.color_attribs # 3));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("joint0: ");
		putuint(deref(p.joint_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("joint1: ");
		putuint(deref(p.joint_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("joint2: ");
		putuint(deref(p.joint_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight0: ");
		putuint(deref(p.weight_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight1: ");
		putuint(deref(p.weight_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight2: ");
		putuint(deref(p.weight_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight3: ");
		putuint(deref(p.weight_attribs # 3));
	}
};

glb_material_verbose_print ::= func(m : glb_material -> v0)
{
	i : u64 mut;
	if(m.name != zero)
	{
		putbytes(m.name, m.name_len);
	}
	else
	{
		putzstr("<unnamed material>");
	}
	putzstr(": [");
	putchar(10);

	putchar(9);
	putzstr("pbrMetallicRoughness: [");
	putchar(10);

	putchar(9);
	putchar(9);
	putzstr("base_colour_texture: ");
	glb_material_texture_verbose_print(m.pbr_metallic_roughness.base_colour_texture);
	putchar(10);

	putchar(9);
	putchar(9);
	putzstr("base colour factor: [");
	base_colour_factor ::= m.pbr_metallic_roughness.base_colour_factor;
	for(i = 0, i < 4, i = i + 1)
	{
		putfloat(deref(base_colour_factor # i));
		if(i < 3)
		{
			putzstr(", ");
		}
	}
	putzstr("]");
	putchar(10);

	if(m.pbr_metallic_roughness.has_metallic_roughness_texture)
	{
		putchar(9);
		putchar(9);
		putzstr("metallic_roughness_texture:: ");
		glb_material_texture_verbose_print(m.pbr_metallic_roughness.metallic_roughness_texture);
		putchar(10);
	}

	putchar(9);
	putchar(9);
	putzstr("metallic factor: ");
	putfloat(m.pbr_metallic_roughness.metallic_factor);
	putchar(10);

	putchar(9);
	putchar(9);
	putzstr("roughness factor: ");
	putfloat(m.pbr_metallic_roughness.roughness_factor);
	putchar(10);

	putchar(9);
	putzstr("],");
	putchar(10);

	if(m.has_normal_texture)
	{
		putchar(9);
		putzstr("normal texture: ");
		glb_material_texture_verbose_print(m.normal_texture);
		putchar(10);
	}

	if(m.has_occlusion_texture)
	{
		putchar(9);
		putzstr("occlusion texture: ");
		glb_material_texture_verbose_print(m.occlusion_texture);
		putchar(10);
	}

	if(m.has_emissive_texture)
	{
		putchar(9);
		putzstr("emissive texture: ");
		glb_material_texture_verbose_print(m.emissive_texture);
		putchar(10);
	}
	putchar(9);
	putzstr("emissive factor: [");
	emissive_factor ::= m.emissive_factor;
	for(i = 0, i < 4, i = i + 1)
	{
		putfloat(deref(emissive_factor # i));
		if(i < 3)
		{
			putzstr(", ");
		}
	}
	putzstr("]");

	putchar(10);
	putzstr("]");
};

glb_material_texture_verbose_print ::= func(t : glb_material_texture -> v0)
{
	putzstr("{");
	putzstr("index: ");
	putuint(t.index);
	putzstr(", ");
	putzstr("texcoord: ");
	putuint(t.texCoord);
	putzstr(", ");
	putzstr("scale: ");
	putfloat(t.scale);
	putzstr("}");
};

glb_verbose_print ::= func(g : glb -> v0)
{
	if(g.errmsg != zero)
	{
		putzstr("glb error: ");
		putzstr(g.errmsg);
		putchar(10);
		return;
	}
	i : u64 mut;
	for(i = 0, i < (g.materials_count), i = i + 1)
	{
		glb_material_verbose_print(deref(g.materials # i));
		putchar(10);
	}
};

glb_badidx : u64 static := -1;

glb ::= struct
{
	errmsg : u8?;
	json : json_data;
	bin : glb_binary_chunk;

	default_scene : u64;
	scenes : glb_scene mut?;
	scenes_count : u64;

	nodes : glb_node mut?;
	nodes_count : u64;

	views : glb_view mut?;
	views_count : u64;

	accessors : glb_accessor mut?;
	accessors_count : u64;

	meshes : glb_mesh mut?;
	meshes_count : u64;
};

glb_view ::= struct
{
	// optional - default zero
	offset : u64;
	length : u64;
	// optional - default badidx
	stride : u64;
	// optional - default badidx
	target : u64;
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
};

glb_binary_chunk ::= struct
{
	data : u8?;
	length : u64;
};

glb_scene ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default zero
	node_indices : u64?;
	// optional - default zero
	node_indices_count : u64;
};

glb_node ::= struct
{
	// optional - default zero
	name : u8?;
	// optional - default zero
	name_len : u64;
	// optional - default badidx
	mesh_idx : u64;
	// optional - default badidx
	skin_idx : u64;
};

glb_accessor ::= struct
{
	view_idx : u64;
	// optional - default 0
	offset : u64;
	component_type: u64;
	count : u64;
	type : u8?;
	type_len : u64;
};

glb_mesh ::= struct
{
	name : u8?;
	name_len : u64;
	primitives : glb_mesh_primitive mut?;
	primitives_count : u64;
};

glb_mesh_primitive ::= struct
{
	mode : u64;
	indices : u64;
	position_attrib : u64;
	normal_attrib : u64;
	tangent_attrib : u64;
	texcoord_attribs : u64 mut[4];
	color_attribs : u64 mut[4];
	joint_attribs : u64 mut[4];
	weight_attribs : u64 mut[4];
};

glb_scene_verbose_print ::= func(s : glb_scene -> v0)
{
	putbytes(s.name, s.name_len);
	putzstr(": [");
	i : u64 mut;
	for(i = 0, i < (s.node_indices_count), i = i + 1)
	{
		putuint(deref(s.node_indices # i));
		if(i < (s.node_indices_count - 1))
		{
			putchar(' ');
		}
	}
	putzstr("]");
};

glb_node_verbose_print ::= func(n : glb_node -> v0)
{
	putbytes(n.name, n.name_len);
	putzstr(" [mesh: ");
	putuint(n.mesh_idx);
	putzstr(", skin: ");
	putuint(n.skin_idx);
	putzstr("]");
};

glb_view_verbose_print ::= func(n : glb_view -> v0)
{
	if(n.name != zero)
	{
		putbytes(n.name, n.name_len);
	}
	else
	{
		putzstr("<unnamed view>");
	}
	putzstr(" [offset: ");
	putuint(n.offset);
	putzstr(", length: ");
	putuint(n.length);
	putzstr(", stride: ");
	putuint(n.stride);
	putzstr(", target: ");
	putuint(n.target);
	putzstr("]");
};

glb_mesh_verbose_print ::= func(m : glb_mesh -> v0)
{
	if(m.name != zero)
	{
		putbytes(m.name, m.name_len);
	}
	else
	{
		putzstr("<unnamed mesh>");
	}
	i : u64 mut;
	for(i = 0, i < (m.primitives_count), i = i + 1)
	{
		p ::= deref(m.primitives # i);
		putchar(10);
		putchar(9);
		putzstr("[mode: ");
		putuint(p.mode);
		putzstr(", indices: ");
		putuint(p.indices);
		putzstr(", attribs: {");
		putchar(10);
		putchar(9);putchar(9);
		putzstr("position: ");
		putuint(p.position_attrib);

		putchar(10);
		putchar(9);putchar(9);
		putzstr("normal: ");
		putuint(p.normal_attrib);

		putchar(10);
		putchar(9);putchar(9);
		putzstr("tangent: ");
		putuint(p.tangent_attrib);

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord0: ");
		putuint(deref(p.texcoord_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord1: ");
		putuint(deref(p.texcoord_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord2: ");
		putuint(deref(p.texcoord_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("texcoord3: ");
		putuint(deref(p.texcoord_attribs # 3));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color0: ");
		putuint(deref(p.color_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color1: ");
		putuint(deref(p.color_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color2: ");
		putuint(deref(p.color_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("color3: ");
		putuint(deref(p.color_attribs # 3));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("joint0: ");
		putuint(deref(p.joint_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("joint1: ");
		putuint(deref(p.joint_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("joint2: ");
		putuint(deref(p.joint_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight0: ");
		putuint(deref(p.weight_attribs # 0));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight1: ");
		putuint(deref(p.weight_attribs # 1));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight2: ");
		putuint(deref(p.weight_attribs # 2));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight3: ");
		putuint(deref(p.weight_attribs # 3));

		putchar(10);
		putchar(9);putchar(9);
		putzstr("weight3: ");
		putuint(deref(p.weight_attribs # 3));
		putzstr("]");
	}
};

glb_verbose_print ::= func(g : glb -> v0)
{
	if(g.errmsg != zero)
	{
		putzstr("glb error: ");
		putzstr(g.errmsg);
		putchar(10);
		return;
	}
	i : u64 mut;
	for(i = 0, i < (g.meshes_count), i = i + 1)
	{
		glb_mesh_verbose_print(deref(g.meshes # i));
		putchar(10);
	}
};
